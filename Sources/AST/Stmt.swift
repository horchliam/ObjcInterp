// Autogenerated by generateAST.py

protocol StmtVisitor {
   associatedtype StmtVisitorReturnType
   func visitBlockStmt(_ stmt: Stmt.Block) throws -> StmtVisitorReturnType
   func visitExpressionStmt(_ stmt: Stmt.Expression) throws -> StmtVisitorReturnType
   func visitIfStmt(_ stmt: Stmt.If) throws -> StmtVisitorReturnType
   func visitVarStmt(_ stmt: Stmt.Var) throws -> StmtVisitorReturnType
   func visitReturnStmt(_ stmt: Stmt.Return) throws -> StmtVisitorReturnType
   func visitWhileStmt(_ stmt: Stmt.While) throws -> StmtVisitorReturnType
   func visitForStmt(_ stmt: Stmt.For) throws -> StmtVisitorReturnType
   func visitPrintStmt(_ stmt: Stmt.Print) throws -> StmtVisitorReturnType
   func visitFunctionStmt(_ stmt: Stmt.Function) throws -> StmtVisitorReturnType
   func visitClassDefStmt(_ stmt: Stmt.ClassDef) throws -> StmtVisitorReturnType
   func visitClassImplStmt(_ stmt: Stmt.ClassImpl) throws -> StmtVisitorReturnType
   func visitTypeDefStmt(_ stmt: Stmt.TypeDef) throws -> StmtVisitorReturnType
}

class Stmt {
   func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
       fatalError()
   }

    class Block: Stmt {
        let statements: [Stmt]

        init(statements: [Stmt]) {
            self.statements = statements
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitBlockStmt(self)
        }
    }

    class Expression: Stmt {
        let expression: Expr

        init(expression: Expr) {
            self.expression = expression
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitExpressionStmt(self)
        }
    }

    class If: Stmt {
        let condition: Expr
        let thenBranch: Stmt
        let elseBranch: Stmt?

        init(condition: Expr, thenBranch: Stmt, elseBranch: Stmt?) {
            self.condition = condition
            self.thenBranch = thenBranch
            self.elseBranch = elseBranch
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitIfStmt(self)
        }
    }

    class Var: Stmt {
        let type: Expr.MyType
        let name: Token
        let initializer: Expr?

        init(type: Expr.MyType, name: Token, initializer: Expr?) {
            self.type = type
            self.name = name
            self.initializer = initializer
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitVarStmt(self)
        }
    }

    class Return: Stmt {
        let value: Expr?

        init(value: Expr?) {
            self.value = value
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitReturnStmt(self)
        }
    }

    class While: Stmt {
        let condition: Expr
        let body: Stmt

        init(condition: Expr, body: Stmt) {
            self.condition = condition
            self.body = body
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitWhileStmt(self)
        }
    }

    class For: Stmt {
        let initializer: Stmt?
        let condition: Expr?
        let change: Expr?
        let body: Stmt

        init(initializer: Stmt?, condition: Expr?, change: Expr?, body: Stmt) {
            self.initializer = initializer
            self.condition = condition
            self.change = change
            self.body = body
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitForStmt(self)
        }
    }

    class Print: Stmt {
        let value: Expr

        init(value: Expr) {
            self.value = value
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitPrintStmt(self)
        }
    }

    class Function: Stmt {
        let name: Token
        let params: [(Expr.MyType,Token)]
        let body: [Stmt]
        let isStatic: Bool

        init(name: Token, params: [(Expr.MyType,Token)], body: [Stmt], isStatic: Bool) {
            self.name = name
            self.params = params
            self.body = body
            self.isStatic = isStatic
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitFunctionStmt(self)
        }
    }

    class ClassDef: Stmt {
        let name: Token
        let superclass: Expr.Variable?
        let methods: [Stmt.Function]
        let properties: [Stmt.Var]

        init(name: Token, superclass: Expr.Variable?, methods: [Stmt.Function], properties: [Stmt.Var]) {
            self.name = name
            self.superclass = superclass
            self.methods = methods
            self.properties = properties
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitClassDefStmt(self)
        }
    }

    class ClassImpl: Stmt {
        let name: Token
        let methods: [Stmt.Function]
        let properties: [Stmt.Var]

        init(name: Token, methods: [Stmt.Function], properties: [Stmt.Var]) {
            self.name = name
            self.methods = methods
            self.properties = properties
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitClassImplStmt(self)
        }
    }

    class TypeDef: Stmt {
        let name: Token
        let newType: Expr.MyType

        init(name: Token, newType: Expr.MyType) {
            self.name = name
            self.newType = newType
        }

        override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturnType {
            return try visitor.visitTypeDefStmt(self)
        }
    }
}

extension Stmt: Hashable {
    static func == (lhs: Stmt, rhs: Stmt) -> Bool {
        return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
    }

    func hash(into hasher: inout Hasher) {
        return ObjectIdentifier(self).hash(into: &hasher)
    }
}
