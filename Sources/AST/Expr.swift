// Autogenerated by generateAST.py

protocol ExprVisitor {
   associatedtype ExprVisitorReturnType
   func visitAssignExpr(_ expr: Expr.Assign) throws -> ExprVisitorReturnType
   func visitBinaryExpr(_ expr: Expr.Binary) throws -> ExprVisitorReturnType
   func visitGroupingExpr(_ expr: Expr.Grouping) throws -> ExprVisitorReturnType
   func visitLiteralExpr(_ expr: Expr.Literal) throws -> ExprVisitorReturnType
   func visitUnaryExpr(_ expr: Expr.Unary) throws -> ExprVisitorReturnType
   func visitVariableExpr(_ expr: Expr.Variable) throws -> ExprVisitorReturnType
   func visitLogicalExpr(_ expr: Expr.Logical) throws -> ExprVisitorReturnType
   func visitTernaryExpr(_ expr: Expr.Ternary) throws -> ExprVisitorReturnType
   func visitCallExpr(_ expr: Expr.Call) throws -> ExprVisitorReturnType
   func visitArrayExpr(_ expr: Expr.Array) throws -> ExprVisitorReturnType
   func visitArrayGetExpr(_ expr: Expr.ArrayGet) throws -> ExprVisitorReturnType
   func visitArraySetExpr(_ expr: Expr.ArraySet) throws -> ExprVisitorReturnType
   func visitGetExpr(_ expr: Expr.Get) throws -> ExprVisitorReturnType
   func visitSetExpr(_ expr: Expr.Set) throws -> ExprVisitorReturnType
   func visitSuperyExpr(_ expr: Expr.Supery) throws -> ExprVisitorReturnType
   func visitSelfyExpr(_ expr: Expr.Selfy) throws -> ExprVisitorReturnType
   func visitMyTypeExpr(_ expr: Expr.MyType) throws -> ExprVisitorReturnType
   func visitBlockExprTypeExpr(_ expr: Expr.BlockExprType) throws -> ExprVisitorReturnType
   func visitBlockExprExpr(_ expr: Expr.BlockExpr) throws -> ExprVisitorReturnType
}

class Expr {
   func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
       fatalError()
   }

    class Assign: Expr {
        let name: Token
        let oper: Token
        let value: Expr

        init(name: Token, oper: Token, value: Expr) {
            self.name = name
            self.oper = oper
            self.value = value
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitAssignExpr(self)
        }
    }

    class Binary: Expr {
        let left: Expr
        let oper: Token
        let right: Expr

        init(left: Expr, oper: Token, right: Expr) {
            self.left = left
            self.oper = oper
            self.right = right
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitBinaryExpr(self)
        }
    }

    class Grouping: Expr {
        let expr: Expr

        init(expr: Expr) {
            self.expr = expr
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitGroupingExpr(self)
        }
    }

    class Literal: Expr {
        let value: Any?

        init(value: Any?) {
            self.value = value
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitLiteralExpr(self)
        }
    }

    class Unary: Expr {
        let oper: Token
        let right: Expr

        init(oper: Token, right: Expr) {
            self.oper = oper
            self.right = right
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitUnaryExpr(self)
        }
    }

    class Variable: Expr {
        let name: Token

        init(name: Token) {
            self.name = name
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitVariableExpr(self)
        }
    }

    class Logical: Expr {
        let left: Expr
        let oper: Token
        let right: Expr

        init(left: Expr, oper: Token, right: Expr) {
            self.left = left
            self.oper = oper
            self.right = right
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitLogicalExpr(self)
        }
    }

    class Ternary: Expr {
        let condition: Expr
        let thenExpr: Expr
        let elseExpr: Expr

        init(condition: Expr, thenExpr: Expr, elseExpr: Expr) {
            self.condition = condition
            self.thenExpr = thenExpr
            self.elseExpr = elseExpr
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitTernaryExpr(self)
        }
    }

    class Call: Expr {
        let callee: Expr
        let args: [Expr]

        init(callee: Expr, args: [Expr]) {
            self.callee = callee
            self.args = args
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitCallExpr(self)
        }
    }

    class Array: Expr {
        let contents: [Expr]

        init(contents: [Expr]) {
            self.contents = contents
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitArrayExpr(self)
        }
    }

    class ArrayGet: Expr {
        let object: Expr
        let index: Expr

        init(object: Expr, index: Expr) {
            self.object = object
            self.index = index
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitArrayGetExpr(self)
        }
    }

    class ArraySet: Expr {
        let object: Expr
        let index: Expr
        let value: Expr
        let oper: Token

        init(object: Expr, index: Expr, value: Expr, oper: Token) {
            self.object = object
            self.index = index
            self.value = value
            self.oper = oper
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitArraySetExpr(self)
        }
    }

    class Get: Expr {
        let object: Expr
        let name: Token

        init(object: Expr, name: Token) {
            self.object = object
            self.name = name
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitGetExpr(self)
        }
    }

    class Set: Expr {
        let object: Expr
        let name: Token
        let value: Expr
        let oper: Token

        init(object: Expr, name: Token, value: Expr, oper: Token) {
            self.object = object
            self.name = name
            self.value = value
            self.oper = oper
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitSetExpr(self)
        }
    }

    class Supery: Expr {
        let keyword: Token

        init(keyword: Token) {
            self.keyword = keyword
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitSuperyExpr(self)
        }
    }

    class Selfy: Expr {
        let keyword: Token

        init(keyword: Token) {
            self.keyword = keyword
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitSelfyExpr(self)
        }
    }

    class MyType: Expr {
        let type: Token?
        let exprType: Expr?

        init(type: Token?, exprType: Expr?) {
            self.type = type
            self.exprType = exprType
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitMyTypeExpr(self)
        }
    }

    class BlockExprType: Expr {
        let returnType: MyType
        let name: Token?
        let params: [MyType]

        init(returnType: MyType, name: Token?, params: [MyType]) {
            self.returnType = returnType
            self.name = name
            self.params = params
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitBlockExprTypeExpr(self)
        }
    }

    class BlockExpr: Expr {
        let returnType: MyType?
        let params: [(MyType,Token)]
        let body: [Stmt]

        init(returnType: MyType?, params: [(MyType,Token)], body: [Stmt]) {
            self.returnType = returnType
            self.params = params
            self.body = body
        }

        override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturnType {
            return try visitor.visitBlockExprExpr(self)
        }
    }
}

extension Expr: Hashable {
    static func == (lhs: Expr, rhs: Expr) -> Bool {
        return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
    }

    func hash(into hasher: inout Hasher) {
        return ObjectIdentifier(self).hash(into: &hasher)
    }
}
